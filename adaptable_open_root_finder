from numpy import * 
"""

"""

### The following 4 functions are single-iteration root finding methods
def NR(x, f, f_prime): 
    return x - f(x)/f_prime(x)
    
def NR_mod(x, f, f_prime, f_doubleprime): 
    return x - f(x)*f_prime(x)/(f_prime(x)**2 - f(x)*f_doubleprime(x))
    
def secant(x1, x2, f): 
    return x2 - f(x2)*(x1 - x2)/(f(x1) - f(x2))
    
def secant_mod(x1, x2, f, f_prime):
    return x2 - (f(x2)/f_prime(x2))*(f(x2)*(x1 - x2)/((f(x1)/f_prime(x1)) - (f(x2)/f_prime(x2))))

### The following two functions are multi-iteration and combined root finding methods 
def NR_iters(x0, f, f_prime):
    x = []
    x.append(x0) 
    ea = 1 
    
    i = 0 
    while ea > 10**-5: 
        x.append( NR(x[i],f, f_prime))

        ea = abs((x[i+1] - x[i])/x[i+1])
        i += 1
    
    print("It took ", i, " iterations to reach the value ", x[-1])

    return x 

def NR_mod_iters(x0, f, f_prime, f_doubleprime):
    x = []
    x.append(x0) 
    ea = 1 
    
    i = 0 
    while ea > 10**-5: 
        #x.append( NR_mod(x[i],f, f_prime, f_doubleprime))
        if f(x[i]) != 0: #Raltson and Rabonowitz theoretically demonstrated that f(x) goes to zero faster then f'(x) 
           x.append( NR_mod(x[i],f, f_prime, f_doubleprime))
        elif f(x[i]) == 0:
            x.append(secant(x[i-1], x[i], f))
            print("Had to switch to secant after ", i, "iterations ")
        ea = abs((x[i+1] - x[i])/x[i+1])
        i += 1
    print("It took ", i, " iterations to reach the value ", x[-1])
        
    return x 

def secant_iters(x0, x1, f):
    x = []
    x.append(x0) 
    x.append(x1)
    ea = 1 
    
    i = 0 
    while ea > 10**-5: 
        x.append(secant(x0, x1, f))

        ea = abs((x[i+1] - x[i])/x[i+1])
        i += 1
    print("It took ", i, " iterations to reach the value ", x[-1])

    return x 

def secant_mod_iters(x0, x1, f):
    x = []
    x.append(x0) 
    x.append(x1)
    ea = 1 
    
    i = 0 
    while ea > 10**-5: 
        x.append(secant(x0, x1, f))

        ea = abs((x[i+1] - x[i])/x[i+1])
        i += 1
    print("It took ", i, " iterations to reach the value ", x[-1])
    return x 


def single_root(x0, f, f_prime): 
    x = []
    x.append(x0) 
    ea = 1 
    
    i = 0 
    while ea > 10**-5: 
            
        if f(x[i]) != 0: #Raltson and Rabonowitz theoretically demonstrated that f(x) goes to zero faster then f'(x) 
            x.append( NR(x[i],f, f_prime))
        elif f(x[i]) == 0:
            x.append(secant(x[i-1], x[i], f))
            print("Had to switch to secant")
                 
        ea = abs((x[i+1] - x[i])/x[i+1])
        i += 1
        
    return x 
    
def multi_root(x0, num_of_roots, f, f_prime, f_doubleprime): 
    root = []
    
    for roots in range(num_of_roots):
        x = []
        x.append(x0[roots]) 
        ea = 1 
        
        i = 0 
        while ea > 10**-5: 
            
            if f(x[i]) != 0: #Raltson and Rabonowitz theoretically demonstrated that f(x) goes to zero faster then f'(x) 
                x.append(NR(x[i],f, f_prime))
            elif f(x[i]) ==0 :
                x.append(NR_mod(x[i],f, f_prime, f_doubleprime))
            
                
            ea = abs((x[i+1] - x[i])/x[i+1])
            i += 1 
        root.append(x[-1])
        
    return root

def even_multi_root(x0, m, num_of_roots, f, f_prime, f_doubleprime):
    root = []
    
    for roots in range(num_of_roots):
        x = []
        x.append(x0[roots]) 
        ea = 1 
        
        i = 0 
        while ea > 10**-5: 
            
            if f(x[i]) != 0: #Raltson and Rabonowitz theoretically demonstrated that f(x) goes to zero faster then f'(x) 
                x.append(x[i] - m[roots]*f(x[i])/f_prime(x[i]))
            elif f(x[i]) ==0 :
                x.append(x[i] - m[roots]*f(x[i])*f_prime(x[i])/(f_prime(x[i])**2 - f(x[i])*f_doubleprime(x[i])))
            
                
            ea = abs((x[i+1] - x[i])/x[i+1])
            i += 1 
        root.append(x[-1])
        
    return root
        
        
########################################################################################################################
if __name__ == "__main__":
    
    # Example 1: Proof of function 
    '''
    Defining the function and derivative for 
    Leonardo de Pisa's polynomial: 
    $x^3 + 2x^2 + 10x - 20$ 
    whose root is 1.368808107
    '''
    f = lambda x: x**3 + 2*x**2 + 10*x - 20 
    fp = lambda x: 3*x**2 + 4*x + 10
    fdp = lambda x: 6*x + 4
    
    pisa_root = single_root(1,f, fp)
    print(pisa_root[-1])
    
    # # Example 2: Multiply roots with odd multiplicity 
    f = lambda x: .5*exp(x) - 5*x + 2
    fp = lambda x: .5*exp(x) - 5 
    fdp = lambda x: .5*exp(x)
    
    roots = multi_root([0,2.5], 2, f, fp, fdp)
    print(roots)
    
    # # Example 3: Even multiplicity
    f = lambda x: x**4 + 2*x**3 - 3*x**2 - 4*x + 4 
    fp = lambda x: 4*x**3 + 6*x**2 - 6*x - 4 
    fdp = lambda x: 12*x**2 + 12*x - 6 
    even_roots = even_multi_root([-1.88, 1.88, 1.6, -2.3], [2,2, 2, 2], 4, f, fp, fdp)
    print(even_roots)
    
    # Example 4: The mixing of methods 
    
    f = lambda x: x**2 + 5*x + 6.25 
    fp = lambda x: 2*x + 5 
    fdp = lambda x: 2
    
    nr_mod = NR_mod_iters(-1, f, fp, fdp)
    
    # Example 5: NR vs NR Modified 
    
    
    
    
